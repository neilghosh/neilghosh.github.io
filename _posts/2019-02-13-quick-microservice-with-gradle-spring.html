---
layout: post
title: Quick Microservice With Gradle Spring Boot Docker
date: '2019-02-13T22:49:00.001+05:30'
author: Neil Ghosh
tags:
- Microservice
- Docker
- Gradle
- Spring Boot
modified_time: '2019-02-24T11:33:04.693+05:30'
blogger_id: tag:blogger.com,1999:blog-6081677503074893817.post-7625834217176705545
blogger_orig_url: https://www.neilghosh.com/2019/02/quick-microservice-with-gradle-spring.html
---

 <div dir="ltr" style="text-align: left;" trbidi="on">A few years ago if you would have asked me to create a quick POC backend service with some rest APIs I would             have just picked up NetBeans and <a href="https://netbeans.org/kb/docs/websvc/rest.html">created the REST                 APIs</a> using jersey/glassfish (reference implementation of JSR 311 RESTful Web Services) from the UI             itself. While the above is an example of creating REST APIs bottom-up from the Database layer, once can plug             business logic by adding few more java classes or a service layer. Lately, I have been using Spring Boot a             lot in production and it really makes the developer's life easy by not having to write a lot of boilerplate             code. Annotations take care of Dependency injection, singleton, REST API mappings etc. It even has the             embedded Jetty web server to run the service locally without really having to install a bulk of binary like             Glassfish/Tomcat server and deploy them (comes integrated with Netbeans tough - one could right click and             run the service). However, Spring Boot + Gradle makes the code ultraportable. All you need to do is             check-out from the code repo and run Gradle/Spring Boot command to build or run. Even the testing tools can             be easily added to gradle and both Unit and Integration test can be written. There are so may example of             hello world with Spring Boot and Gradle on the internet, but I thought of keeping a copy of simple skeleton             of service which I can use to bootstrap any app in future. Even better - dockerize the app and create an             image out of it which can run anywhere irrespective of the host machine and its setup. Later we can also             push it to a public container registry and use it in Minikube or Kubernetes in the cloud (probably in a             separate post).<br /><br />I assume one has installed Java and gradle (only needed for creating the project but the subsequent setup             will be taken care by gradlew, the wrapper which can download gradle itself)<br /><h3>                Code</h3>To create a skeleton<br /><pre>  <code class="bash"><br />     gradle init --type java-application <br />  </code><br /></pre>Now add the spring boot dependencies in build.gragle. <br /><br /><pre>  <code class="gradle"><br />   plugins {<br />   ...<br />       id 'com.gradle.build-scan' version '1.16'<br />       id 'org.springframework.boot' version '2.0.5.RELEASE'<br />  }<br />  </code><br /></pre><br /><pre>  <code class="gradle"><br />dependencies {<br />// This dependency is found on compile classpath of this component and consumers.<br />    implementation 'org.springframework.boot:spring-boot-dependencies:2.0.5.RELEASE'<br />    implementation 'org.springframework.boot:spring-boot-starter-web:2.0.5.RELEASE'<br />  </code><br /></pre><br /><pre><code class="java"><br />import org.springframework.boot.SpringApplication;<br />import org.springframework.boot.autoconfigure.SpringBootApplication;<br /><br />@SpringBootApplication<br />public class App {dle<br />    public static void main(String[] args) {<br />    SpringApplication.run(App.class, args);<br />    }<br />}<br /></code><br /></pre><br />Now tell gradle (in build.gradle)which one is the main class<br /><br /><pre><code class="gradle"><br /> bootJar {<br />     mainClassName = 'hello.App'<br /> }<br /></code><br /></pre><br />The whole code can be checked out from<br /><blockquote class="tr_bq">git clone https://github.com/neilghosh/simple-gradle-springboot-service </blockquote><h3 style="text-align: left;">                Build </h3>Now one can build the jar with all the dependencies<br /><blockquote class="tr_bq">./gradlew bootJar </blockquote>the jar will be created in the ./build directory.<br /><br /><h3 style="text-align: left;">                Run </h3><br />Now we can run the app by either<br /><blockquote class="tr_bq">./gradlew bootRun</blockquote>or run the jar itself<br /><blockquote class="tr_bq">java -jar build/libs/simple-gradle-springboot-service .jar</blockquote><h4 style="text-align: left;">                <b>Dockerize </b></h4>We can create the following simple Dockerfile to import the OpenJDK base image and copy the jar to an             appropriiate directory and run command.<br /><br /><pre><code class="dockerfile"><br />      FROM openjdk:8-jdk-alpine<br />      RUN mkdir -p /app/<br />      ADD    build/libs/simple-gradle-springboot-service.jar /app/app.jar<br />      ENTRYPOINT ["java", "-jar", "/app/app.jar"]<br /></code><br /></pre><br />Build the docker image<br /><blockquote class="tr_bq">docker build . -t gradle-spring-boot-app </blockquote>Check the local image created<br /><blockquote class="tr_bq">docker images </blockquote>REPOSITORY TAG IMAGE ID CREATED SIZE<br />gradle-spring-boot-app latest 21572d4766d3 About an hour ago 124MB<br /><br />And run the docker image exposing the port to host<br /><blockquote class="tr_bq">docker run -p 8080:8080 gradle-spring-boot-app:latest</blockquote>Profit<br /><blockquote class="tr_bq">$ curl http://localhost:8080/<br />Hello Gradle!</blockquote>Next, we will see how to push the local cached imaged to a docker registry and run in cloud or Minikube         </div> 