---
layout: post
title: Google AppEngine Channel API
date: '2013-06-26T17:46:00.000+05:30'
author: Neil Ghosh
tags:
- Channel API
- Appengine
- Game server
- Google
- realtime
- Javascript
- Websocket
- Code
- java
modified_time: '2014-10-11T20:22:38.410+05:30'
blogger_id: tag:blogger.com,1999:blog-6081677503074893817.post-4460329348343557076
blogger_orig_url: https://www.neilghosh.com/2013/06/google-appengine-channel-api.html
---

I am not a big fan of page refresh for getting new data from server. AJAX has been the go to technology for these kind of requirements. However its unidirectional. For two way communication where server push is required , we have seen many technologies like comet etc. <a href="http://html5demos.com/web-socket" target="_blank">Websocket</a> and <a href="http://www.html5rocks.com/en/tutorials/webrtc/basics/" target="_blank">WebRTC</a> has been really cool technologies which helps sending data from server and client real time. These needs special server code for handling such requests. I have already worked on J<a title="Online slate board using HTML5 websocket and glassfish" href="http://neilghosh.com/2013/01/31/online-slate-board-using-html5-websocket-and-glassfish/" target="_blank">SR 356 for websocket</a> and <a title="Adopt-A-JSR at JUG Hyderabad" href="http://neilghosh.com/2013/01/30/adopt-a-jsr-at-jug-hyderabad/" target="_blank">glassfish reference implementation (tyrus)</a> earlier. However in Google Appengine provides <a href="https://developers.google.com/appengine/docs/java/channel/" target="_blank">channel APIs</a> for bidirectional communication. While client to server communication is still over HTTP GET or POST, sever creates a specific "channel" and enables itself to push data any time to specific clients. Under the hood , its actually the client which keeps polling with GET requests for new data to be sent by the server. In any case this API can be use fill in real time game servers.<br/><br/><strong>The server side code</strong><br/><br/>I added the following code to the example given in the previous post to use channel APIs<br/><br/>[code language="java"]<br/>    private void boradCastNotes(Request request,Note note) {<br/>        ServletContext context = hsr.getSession().getServletContext();<br/>        HashMap&lt;String,ChannelPresence&gt; liveUsers = (HashMap&lt;String,ChannelPresence&gt;)context.getAttribute(&quot;liveUsers&quot;);<br/>        if(liveUsers != null){<br/>            ChannelService channelService = ChannelServiceFactory.getChannelService();<br/>            ObjectMapper mapper = new ObjectMapper();<br/>            System.out.println(&quot;List of connected client ... &quot;);<br/>            String noteStr = null;<br/>            try {<br/>                noteStr = mapper.writeValueAsString(note);<br/>            } catch (IOException e) {<br/>                e.printStackTrace();  //To change body of catch statement use File | Settings | File Templates.<br/>            }<br/>            for(ChannelPresence cp : liveUsers.values()){<br/>                System.out.println(cp.clientId());<br/>                System.out.print(&quot; Sending message to client --&gt; &quot; +noteStr);<br/>                String channelMessageStr=&quot;{&quot;command&quot;:&quot;note&quot;,&quot;data&quot;:&quot;+noteStr+&quot;}&quot;;<br/>                System.out.print(&quot; Sending message to client after wrapping --&gt; &quot; +channelMessageStr);<br/>                channelService.sendMessage(new ChannelMessage(cp.clientId(),channelMessageStr));<br/><br/>            }<br/>        }<br/>    }<br/>[/code]<br/><br/><strong>Client Code</strong><br/><br/>In HTML I added an extra button which will send the user entered data using an AJAX request and some JavaScript code to create the channel using the token issues by the server earlier.<br/><br/>[code language="JavaScript"]<br/>&lt;script language=&quot;JavaScript&quot;&gt;<br/><br/>    //Function called when update button us pressed<br/>    //This will maken an AJAX POST request<br/>    //To the webservice created using sitebricks<br/>    postnote = function(){<br/>        var noteObj = new Object();<br/>        noteObj.text=document.forms[0]['note.text'].value;<br/>        sendMessage('/notes','POST',JSON.stringify(noteObj));<br/>    };<br/>    //Generic method for sending any Ajax request<br/>    sendMessage = function(path, method,param) {<br/>        var xhr = new XMLHttpRequest();<br/>        xhr.open(method, path, true);<br/>        //Callback when response is received from the server<br/>        xhr.onload = function () {<br/>            console.log(this.responseText);<br/>            document.forms[0]['note.text'].value=&quot;&quot;;<br/>            };<br/>        xhr.send(param);<br/>        };<br/><br/>    onOpened = function() {<br/>        sendMessage('/notes','GET','command=open');<br/>    };<br/><br/>    onMessage = function(message){<br/>        //When message is recived from the server<br/>        //Message.data contains the actual string send by the<br/>        //Java code<br/>        //Now convert the JSON string to a Javascript Object<br/>        var data = eval(&quot;(&quot; + message.data + &quot;)&quot;);<br/>        console.log(&quot;Received data from Server &quot;+data)<br/>        //Adds a new note row in the tables<br/>        if(data.command==&quot;note&quot;){<br/>            insertRow(data.data)<br/>        }<br/>    }<br/><br/>    insertRow = function(data){<br/>        var table=document.getElementById(&quot;noteTable&quot;);<br/>        var row=table.insertRow(1);<br/>        var cell1=row.insertCell(0);<br/>        var cell2=row.insertCell(1);<br/>        cell1.innerHTML=new Date(data.date);<br/>        cell2.innerHTML=data.text;<br/>    }<br/><br/>    //Opens a channel with server with the given token (provided by the server)<br/>    //Internally it keeps polling the server for new messages<br/>    channel = new goog.appengine.Channel('${token}');<br/>    socket = channel.open();<br/>    //Define all the listeners<br/>    socket.onopen = onOpened;<br/>    socket.onmessage = onMessage;<br/>    socket.onerror = onError;<br/>    socket.onclose = onClose;<br/>&lt;/script&gt;<br/>[/code]<br/><br/><strong>Other features</strong><br/><br/>To track the clients which gets connected to the server , listeners can be added to a specific urls.I track the clients to broadcast the messages to all the connected clients.To enable tracking following needs to be added to appengine-web.xml<br/><br/>[code language="XML"]<br/>    &lt;inbound-services&gt;<br/>        &lt;service&gt;channel_presence&lt;/service&gt;<br/>    &lt;/inbound-services&gt;<br/>[/code]<br/><br/>Then write POST endpoint handlers<br/><br/>[code language="Java"]<br/>public class TrackerServlet extends HttpServlet {<br/>    @Override<br/>    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br/>        ChannelService channelService = ChannelServiceFactory.getChannelService();<br/>        ChannelPresence presence = channelService.parsePresence(req);<br/>        System.out.print(&quot;Client trying to connect with ID &quot; + presence.clientId());<br/>        //Save the new client in servlet context<br/>        ServletContext context = getServletContext();<br/>        //Object liveUsers = context.getAttribute(&quot;liveUsers&quot;);<br/>        HashMap&lt;String, ChannelPresence&gt; liveUsers = (HashMap&lt;String, ChannelPresence&gt;) context.getAttribute(&quot;liveUsers&quot;);<br/>        if (null == liveUsers) {<br/>            System.out.println(&quot;Initialising client list&quot;);<br/>            liveUsers = new HashMap&lt;String, ChannelPresence&gt;();<br/>            context.setAttribute(&quot;liveUsers&quot;, liveUsers);<br/>        }<br/>        if(liveUsers.containsKey(presence.clientId())) {<br/>            System.out.println(&quot;Err.... this guy was already connected ! &quot;);<br/>        } else {<br/>            liveUsers.put(presence.clientId(), presence);<br/>            System.out.println(&quot; New client connected with ID  &quot; + presence.clientId());<br/>        }<br/>    }<br/>[/code]<br/><br/><br/>Similarly remove the client from servlet context when client gets disconnected.<br/><br/>[code language="Java"]<br/>public class TrackerServlet1 extends HttpServlet {<br/>    @Override<br/>    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {<br/>        ChannelService channelService = ChannelServiceFactory.getChannelService();<br/>        ChannelPresence presence = channelService.parsePresence(req);<br/>        System.out.print(&quot;Client disconnected with ID &quot; + presence.clientId());<br/><br/>        ServletContext context = getServletContext();<br/>        HashMap&lt;String, ChannelPresence&gt; liveUsers = (HashMap&lt;String, ChannelPresence&gt;) context.getAttribute(&quot;liveUsers&quot;);<br/>        if (null != liveUsers) {<br/>            if (liveUsers.containsKey(presence.clientId())) {<br/>                liveUsers.remove(presence.clientId());<br/>                System.out.println(&quot;Client was disconnected&quot;);<br/>            } else {<br/>                System.out.println(&quot;Client was not connected&quot;);<br/>            }<br/>        } else {<br/>            System.out.println(&quot;No client was ever connected&quot;);<br/>        }<br/>    }<br/>}<br/>[/code]<br/><br/><br/><strong>Note:</strong><br/><ul><br/>	<li><a href="https://github.com/neilghosh/cross-note/tree/0cc7a68e080ccd3c066e6d59023e6218de0a92de" target="_blank">Code in GitHub</a></li><br/>	<li><a href="http://stackoverflow.com/questions/17290780/appengine-devserver-redeployes-application-on-first-request" target="_blank">Application gets redeployed in devserver on the first client request.</a></li><br/></ul><br/>&nbsp;