---
layout: post
title: Container Registry and Minikube
date: '2019-02-20T23:26:00.000+05:30'
author: Neil Ghosh
tags: 
modified_time: '2019-02-25T12:56:25.123+05:30'
blogger_id: tag:blogger.com,1999:blog-6081677503074893817.post-7643151634861395054
blogger_orig_url: https://www.neilghosh.com/2019/02/container-registry-and-minikube.html
---

<div dir="ltr" style="text-align: left;" trbidi="on">In the <a href="https://www.neilghosh.com/2019/02/quick-microservice-with-gradle-spring.html">previous post</a>, we saw how to create a docker image out of a simple gradle/spring boot app and run it locally. In this post, we will push it to a container registry and use it to deploy it in a kubernetes cluster<br /><br /><b>Upload to Registry&nbsp;</b><br /><br />I created an account in <a href="https://cloud.docker.com/">Docker Hub</a>&nbsp;and did a "docker login" in the command line with my credentials.<br /><br /><pre><code class="bash">docker push neilghosh/gradle-spring-boot-app:latest<br /></code></pre><div><br /></div><div>Note docker CLI bu default talks to Docker Hub, however one can log in to other container registries e.g. GCP's GCR or Azure's ACR by prefixing the image name with the fully qualified registry login URL.<br /><br /><b>Install and Setup Minikube</b><br />We can run Kubernetes locally using <a href="https://kubernetes.io/docs/setup/minikube/">Minikube</a>, this gives us the opportunity to develop/deploy/test quickly before we deploy into remote cluster available in <a href="https://cloud.google.com/kubernetes-engine/">GKE</a> or AKS. Minikube uses a virtualization software like Virtual Box to deploy its containers<br /><br /><a href="https://www.virtualbox.org/wiki/Linux_Downloads">Download Virtual Box</a><br /><br />Install Minikube<br /><pre><code class="bash"><br />curl -Lo minikube https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64&nbsp; &amp;&amp; chmod +x minikube</code></pre><div><br />Note one can run minikube without using virtualization software as well but usually not recommended because of security and isolation concerns.<br /><pre><code class="bash"><br />minikube start</code></pre><br />Switch the context of "kubectl" CLI to "minikube" so that any further kubectl command actually talks to&nbsp;the locally installed kubernetes instead of any remote kubernetes cluster that is running and we may have used kubectl to manage that.<br /><br /><pre><code class="bash">## kubectl config get-contexts<br />kubectl config use-context minikube<br />Switched to context "minikube".<br /></code></pre><br /><b>Deploy to Kubernetes</b><br /><br />We can go back to the git repo where we have the simple springboot app and we have added some new configuration files (Kubernetes manifest) which will help in deploying the image from docker hub into the kubernetes cluster&nbsp;</div><div><br /><pre><code class="bash"><br />$ git clone https://github.com/neilghosh/simple-gradle-springboot-service.git<br />$ cd simple-gradle-springboot-service<br />$ kubectl apply -f deploy/app-httpsdeploy.yaml<br /><br />deployment.apps/app-deployment created<br />service/app-backend created<br /></code></pre><br /><br />Get the name of the pod its running the container<br /><pre><code class="bash"><br />23:03 $ kubectl get pods<br /><br />NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; READY&nbsp; &nbsp; &nbsp;STATUS&nbsp; &nbsp; RESTARTS&nbsp; &nbsp;AGE<br /><br />app-deployment-5bb7c7d847-6hlkj&nbsp; &nbsp;1/1&nbsp; &nbsp; &nbsp; &nbsp;Running&nbsp; &nbsp;0&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 11m&lt;</code></pre><div><br /></div><div><b>View/tail the logs from the pod</b><br /><pre><code class="bash"><br />kubectl logs -t app-deployment-5bb7c7d847-6hlkj</code></pre><br />You should be seeing the spring boot logs that was generated at the startup.<br /><br />You can check the services that were created.<br /><br /><pre><code class="bash">23:05 $ kubectl get services<br /><br />NAME&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; TYPE&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;CLUSTER-IP&nbsp; &nbsp; &nbsp; &nbsp;EXTERNAL-IP&nbsp; &nbsp;PORT(S)&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; AGE<br /><br />app-backend&nbsp; &nbsp;LoadBalancer&nbsp; &nbsp;10.98.90.235&nbsp; &nbsp; &nbsp;&nbsp; &nbsp; &nbsp;80:30451/TCP&nbsp; &nbsp; &nbsp;13m<br /><br /></code></pre>Note, since you are running in minikube it does not have any load balancer available like in cloud providers like GCP and AKS. So it will never get an external IP.<br /><br />You can expose the service to the host name and launch in the browser with following<br /><pre><code class="bash"><br />$ minikube service app-backend<br />## Or if you don't want to launch it automatically<br />$ minikube service hello-minikube --url<br />http://192.168.99.103:30451 <br /></code></pre><br />Note : As per <a class="" href="https://github.com/kubernetes/minikube/blob/master/docs/tunnel.md">documentation</a> , you can emulate the load balancer and map it to a local IP. (You need to upgrade minikube to the latest version to use this feature). I haven't really tested it.<br /><pre><code class="bash"><br />minikube tunnel<br /></code></pre><br />You can also see the kubernetes dashboard.<br /><pre><code class="bash"><br /> minikube dashboard</code></pre><pre><code class="bash">&nbsp;</code></pre>Here is the Manifest file that we used to deploy into kubernetes. It has one deployment which uses the simple springboot app image from the docker hub registry and exposes the port 8080.It also has a load balance which directs the traffic at port 80 from the outside of the cluster to the port 8080 of the deployment.<br /><pre><code class="yaml"><br />apiVersion: apps/v1beta1<br />kind: Deployment<br />metadata:<br />  name: app-deployment<br />spec:<br />  replicas: 1<br />  template:<br />    metadata:<br />      labels:<br />        app: app<br />    spec:<br />      containers:<br />      - name: app<br />        image: neilghosh/gradle-spring-boot-app:latest<br />        imagePullPolicy: Always<br />        ports:<br />           - name: http<br />             containerPort: 8080<br />---<br />apiVersion: v1<br />kind: Service<br />metadata:<br /> name: app-backend<br />spec:<br /> type: LoadBalancer<br /> selector:<br />   app: app<br /> ports:<br />  - name: http<br />    protocol: TCP<br />    port: 80<br />    targetPort: 8080<br />---<br /></code></pre>Next time possibly we can deploy it to some remote cluster like <a href="https://cloud.google.com/kubernetes-engine/">GKE</a> and configure HTTPS.</div></div></div></div>